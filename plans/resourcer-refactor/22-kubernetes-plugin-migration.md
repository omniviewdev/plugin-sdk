# 22 — Kubernetes Plugin Migration Guide

**Status:** Active — pre-implementation reference
**Depends on:** [09](09-resource-plugin-sdk-interface-design.md), [20 §14](20-sdk-protocol-versioning.md), [21](21-v1-proto-definitions.md)
**Audience:** Implementer migrating the K8s plugin from current SDK to v1 SDK

---

## Table of Contents

1. [Overview & Component Mapping](#1-overview--component-mapping)
2. [ClientSet Changes](#2-clientset-changes)
3. [ConnectionProvider](#3-connectionprovider)
4. [KubernetesResourcerBase](#4-kubernetesresourcerbase)
5. [Pattern Resourcer](#5-pattern-resourcer)
6. [Code Generator](#6-code-generator)
7. [Actions](#7-actions)
8. [Non-Resource Capabilities](#8-non-resource-capabilities)
9. [ResourceLink → RelationshipProvider](#9-resourcelink--relationshipprovider)
10. [HealthProvider](#10-healthprovider)
11. [Registration & main.go](#11-registration--maingo)
12. [Verification Checklist](#12-verification-checklist)

---

## 1. Overview & Component Mapping

The v1 migration replaces the function-passing / options-bag registration pattern with interface
implementations. The K8s plugin is the **only** resource plugin, so there is no backward-compatibility
concern — every file either migrates or is deleted.

### Current → v1 File Mapping

| Current File | What It Does Today | v1 Outcome |
|---|---|---|
| `pkg/main.go` | Plugin entry point, `sdk.NewPlugin` + `plugin.Serve()` | **Modify** — switch to `sdk.NewPlugin` with v1 config, `sdk.RegisterResourcePlugin[ClientSet]` |
| `pkg/plugin/resource/register_gen.go` | Autogenerated: `Register()`, `resourceMap`, `gvrMap`, 200+ resourcer bindings | **Replace** — new `register_v1.go` using `[]ResourceRegistration[ClientSet]` |
| `pkg/plugin/resource/connections.go` | 8 standalone functions (`LoadConnectionsFunc`, `WatchConnectionsFunc`, etc.) | **Replace** — single `kubeConnectionProvider` struct implementing `ConnectionProvider[ClientSet]` + `ConnectionWatcher` + `ClientRefresher[ClientSet]` + `SchemaProvider[ClientSet]` |
| `pkg/plugin/resource/informer.go` | `kubeInformerHandle` — `RegisterResource()`, `Start()`, `resolveGVR()` | **Delete** — replaced by `Watch()` method on `KubeResourcerBase` |
| `pkg/plugin/resource/resourcers/base.go` | `KubernetesResourcerBase[T]` — CRUD methods taking `*types.PluginContext` | **Modify** — `context.Context` on all methods, add `Watch()` method, implement `Watcher[ClientSet]` |
| `pkg/plugin/resource/resourcers/pattern_resourcer.go` | `KubernetesPatternResourcer` — dynamic REST CRUD | **Modify** — `context.Context` on all methods, does NOT implement `Watcher` |
| `pkg/plugin/resource/resourcers/node_resourcer.go` | `NodeResourcer` — 6 actions (cordon, drain, etc.) | **Modify** — `context.Context`, add `ParamsSchema`/`Dangerous` fields on `ActionDescriptor` |
| `pkg/plugin/resource/resourcers/deployment_resourcer.go` | `DeploymentResourcer` — restart, scale, pause, resume | **Modify** — same as NodeResourcer |
| `pkg/plugin/resource/resourcers/daemonset_resourcer.go` | `DaemonSetResourcer` — restart | **Modify** — same pattern |
| `pkg/plugin/resource/resourcers/statefulset_resourcer.go` | `StatefulSetResourcer` — restart, scale | **Modify** — same pattern |
| `pkg/plugin/resource/resourcers/definitions.go` | `ResourceDefs` map + `DefaultResourceDef` | **Keep** — consumed by `ResourceRegistration.Definition` |
| `pkg/plugin/resource/groups.go` | `ResourceGroups []ResourceGroup` | **Keep** — consumed by `ResourcePluginConfig.Groups` |
| `pkg/plugin/resource/schemas.go` | `FetchOpenAPISchemas()` | **Keep** — called from `SchemaProvider.GetEditorSchemas()` |
| `pkg/plugin/resource/errors.go` | `classifyResourceError()` | **Modify** — wrap in `kubeErrorClassifier` struct implementing `ErrorClassifier` interface |
| `pkg/plugin/resource/clients/clients.go` | `ClientSet` struct, `CreateClient()`, `RefreshClient()` | **Modify** — add `EnsureFactoryStarted()` with `sync.Once`, change `CreateClient`/`RefreshClient` signatures |
| `pkg/plugin/helm/**` | Helm resourcers (Release, Chart, Repo) | **Modify** — `context.Context` on CRUD methods, no `Watcher` (CRUD-only) |
| `pkg/plugin/exec/register.go` | Exec capability registration | **Keep** — import path changes only (doc 20 §13.7) |
| `pkg/plugin/logs/register.go` | Logs capability registration | **Keep** — import path changes only |
| `pkg/plugin/metric/register.go` | Metric capability registration | **Keep** — import path changes only |
| `pkg/plugin/networker/register.go` | Networker capability registration | **Keep** — import path changes only |
| `generators/**` | Code generator (clones K8s, parses OpenAPI) | **Modify** — update template output to emit `[]ResourceRegistration[ClientSet]` |

### Files Deleted

| File | Reason |
|---|---|
| `pkg/plugin/resource/informer.go` | Replaced by `Watch()` on each `Resourcer` |
| `pkg/plugin/resource/register_gen.go` | Replaced by `register_v1.go` (new generator output) |

### New Files Created

| File | Purpose |
|---|---|
| `pkg/plugin/resource/connection_provider.go` | `kubeConnectionProvider` struct |
| `pkg/plugin/resource/register_v1.go` | New registration function using `ResourcePluginConfig` |
| `pkg/plugin/resource/gvr.go` | `resolveGVR()` utility (extracted from deleted `informer.go`) |

---

## 2. ClientSet Changes

### Current

```go
// clients/clients.go
type ClientSet struct {
    Clientset              *kubernetes.Clientset
    KubeClient             kubernetes.Interface
    DiscoveryClient        discovery.DiscoveryInterface
    DynamicClient          dynamic.Interface
    DynamicInformerFactory dynamicinformer.DynamicSharedInformerFactory
    RESTConfig             *rest.Config
}

func CreateClient(ctx *types.PluginContext) (*ClientSet, error) { ... }
func RefreshClient(ctx *types.PluginContext, client *ClientSet) error { ... }
```

### v1

```go
// clients/clients.go
type ClientSet struct {
    Clientset              *kubernetes.Clientset
    KubeClient             kubernetes.Interface
    DiscoveryClient        discovery.DiscoveryInterface
    DynamicClient          dynamic.Interface
    DynamicInformerFactory dynamicinformer.DynamicSharedInformerFactory
    RESTConfig             *rest.Config

    factoryStartOnce sync.Once  // NEW
}

// NEW — idempotent factory start, called from Watch() implementations
func (cs *ClientSet) EnsureFactoryStarted(ctx context.Context) {
    cs.factoryStartOnce.Do(func() {
        cs.DynamicInformerFactory.Start(ctx.Done())
    })
}
```

### Key Changes

1. **`CreateClient` and `RefreshClient` signatures move** into `ConnectionProvider` methods — they no
   longer exist as standalone functions. The connection data comes from `context.Context` via
   `resource.SessionFromContext(ctx).Connection`.
2. **`sync.Once` on factory start** — each `Watch()` call can safely call `EnsureFactoryStarted()`
   without coordinating with other resourcers. The factory starts exactly once per client.
3. **`DynamicInformerFactory` creation** stays in `CreateClient` — the factory is still created eagerly.
   Only `Start()` is deferred to first `Watch()`.

---

## 3. ConnectionProvider

This is the biggest structural change. Eight standalone functions collapse into a single struct
implementing four interfaces.

### Current (8 Functions)

```go
// connections.go — standalone functions passed via ResourcePluginOpts
func LoadConnectionsFunc(ctx *types.PluginContext) ([]types.Connection, error)
func WatchConnectionsFunc(ctx *types.PluginContext) (chan []types.Connection, error)
func LoadConnectionNamespacesFunc(ctx *types.PluginContext, client *ClientSet) ([]string, error)
func CheckConnectionFunc(ctx *types.PluginContext, conn *types.Connection, client *ClientSet) (ConnectionStatus, error)

// clients/clients.go — standalone functions
func CreateClient(ctx *types.PluginContext) (*ClientSet, error)
func RefreshClient(ctx *types.PluginContext, client *ClientSet) error

// schemas.go
func FetchOpenAPISchemas(ctx *types.PluginContext, client *ClientSet, keys []string) ([]EditorSchema, error)

// errors.go
func classifyResourceError(err error) ResourceErrorType
```

### v1 (Single Struct, 4 Interfaces)

```go
// connection_provider.go
type kubeConnectionProvider struct {
    logger *zap.SugaredLogger
}

// Compile-time interface checks
var _ resource.ConnectionProvider[clients.ClientSet]    = (*kubeConnectionProvider)(nil)
var _ resource.ConnectionWatcher                        = (*kubeConnectionProvider)(nil)
var _ resource.ClientRefresher[clients.ClientSet]       = (*kubeConnectionProvider)(nil)
var _ resource.SchemaProvider[clients.ClientSet]         = (*kubeConnectionProvider)(nil)

// --- ConnectionProvider[ClientSet] (required) ---

func (k *kubeConnectionProvider) CreateClient(ctx context.Context) (*clients.ClientSet, error) {
    // session := resource.SessionFromContext(ctx)
    // conn := session.Connection  ← replaces ctx.Connection
    // cfg := session.PluginConfig ← replaces ctx.PluginConfig
    // Build rest.Config from conn.Data["kubeconfig_path"], conn.Data["context_name"]
    // Create all 4 K8s clients + DynamicSharedInformerFactory
    // Return &ClientSet{...}
}

func (k *kubeConnectionProvider) DestroyClient(ctx context.Context, client *clients.ClientSet) error {
    // NEW — not in current code. Stop the informer factory if started.
    // client.DynamicInformerFactory.Shutdown()  (K8s 1.30+)
    return nil
}

func (k *kubeConnectionProvider) LoadConnections(ctx context.Context) ([]types.Connection, error) {
    // session := resource.SessionFromContext(ctx)
    // kubeconfigs from session.PluginConfig.GetStringSlice("kubeconfigs")
    // Same logic as current LoadConnectionsFunc, minus *PluginContext
}

func (k *kubeConnectionProvider) CheckConnection(
    ctx context.Context,
    conn *types.Connection,
    client *clients.ClientSet,
) (types.ConnectionStatus, error) {
    // Same logic as current CheckConnectionFunc
    // enrichConnectionData, enrichConnectionLabels unchanged
}

func (k *kubeConnectionProvider) GetNamespaces(
    ctx context.Context,
    client *clients.ClientSet,
) ([]string, error) {
    // Same logic as current LoadConnectionNamespacesFunc
}

// --- ConnectionWatcher (optional, auto-detected) ---

func (k *kubeConnectionProvider) WatchConnections(
    ctx context.Context,
) (<-chan []types.Connection, error) {
    // Same fsnotify logic as current WatchConnectionsFunc
    // Uses ctx.Done() instead of manual stop channel
}

// --- ClientRefresher[ClientSet] (optional, auto-detected) ---

func (k *kubeConnectionProvider) RefreshClient(
    ctx context.Context,
    client *clients.ClientSet,
) error {
    // Same logic as current clients.RefreshClient
}

// --- SchemaProvider[ClientSet] (optional, auto-detected) ---

func (k *kubeConnectionProvider) GetEditorSchemas(
    ctx context.Context,
    client *clients.ClientSet,
) ([]resource.EditorSchema, error) {
    // Delegates to FetchOpenAPISchemas(ctx, client, registeredKeys)
    // registeredKeys computed at registration time, stored on struct
}
```

### Migration Notes

- **`*types.PluginContext` → `context.Context`**: All connection data accessed via
  `resource.SessionFromContext(ctx)`. The `Session` struct carries `.Connection`, `.PluginConfig`,
  `.GlobalConfig`.
- **`DestroyClient` is new**: Current code has no explicit client teardown. In v1, this is where
  `DynamicSharedInformerFactory.Shutdown()` goes. Implement even if body is minimal — the SDK calls
  it on connection disconnect.
- **fsnotify lifecycle**: Current `WatchConnectionsFunc` creates its own `fsnotify.Watcher`. In v1,
  use `ctx.Done()` for cleanup instead of a manually managed stop channel.
- **Error classifier**: Moves to a separate `kubeErrorClassifier` struct implementing
  `resource.ErrorClassifier`. Single method: `ClassifyError(err error) error`.

---

## 4. KubernetesResourcerBase

The base resourcer is the most critical change. It gains a `Watch()` method that replaces the
entire `informer.go` file.

### Current

```go
// resourcers/base.go
type KubernetesResourcerBase[T MetaAccessor] struct {
    sync.RWMutex
    log          *zap.SugaredLogger
    resourceType schema.GroupVersionResource
}

func (s *KubernetesResourcerBase[T]) Get(
    ctx *types.PluginContext,        // ← *PluginContext
    client *clients.ClientSet,
    _ pkgtypes.ResourceMeta,
    input pkgtypes.GetInput,
) (*pkgtypes.GetResult, error) {
    // Uses client.DynamicInformerFactory directly
    // Falls back to DynamicClient if informer not synced
}
```

### v1

```go
// resourcers/base.go
type KubernetesResourcerBase[T MetaAccessor] struct {
    sync.RWMutex
    log          *zap.SugaredLogger
    resourceType schema.GroupVersionResource
}

// Compile-time interface checks
var _ resource.Resourcer[clients.ClientSet]  = (*KubernetesResourcerBase[MetaAccessor])(nil)
var _ resource.Watcher[clients.ClientSet]    = (*KubernetesResourcerBase[MetaAccessor])(nil)

// --- CRUD (context.Context replaces *PluginContext) ---

func (s *KubernetesResourcerBase[T]) Get(
    ctx context.Context,             // ← context.Context
    client *clients.ClientSet,
    meta resource.ResourceMeta,
    input resource.GetInput,
) (*resource.GetResult, error) {
    // Same informer-or-fallback logic
    // Uses ctx for cancellation (client.DynamicClient...Get(ctx, ...))
}

func (s *KubernetesResourcerBase[T]) List(
    ctx context.Context,
    client *clients.ClientSet,
    meta resource.ResourceMeta,
    input resource.ListInput,
) (*resource.ListResult, error) { /* same logic, ctx propagated */ }

func (s *KubernetesResourcerBase[T]) Find(
    ctx context.Context,
    client *clients.ClientSet,
    meta resource.ResourceMeta,
    input resource.FindInput,
) (*resource.FindResult, error) { /* same logic, ctx propagated */ }

func (s *KubernetesResourcerBase[T]) Create(
    ctx context.Context,
    client *clients.ClientSet,
    meta resource.ResourceMeta,
    input resource.CreateInput,
) (*resource.CreateResult, error) { /* same logic */ }

func (s *KubernetesResourcerBase[T]) Update(
    ctx context.Context,
    client *clients.ClientSet,
    meta resource.ResourceMeta,
    input resource.UpdateInput,
) (*resource.UpdateResult, error) { /* same logic */ }

func (s *KubernetesResourcerBase[T]) Delete(
    ctx context.Context,
    client *clients.ClientSet,
    meta resource.ResourceMeta,
    input resource.DeleteInput,
) (*resource.DeleteResult, error) { /* same logic */ }

// --- Watcher[ClientSet] (NEW — replaces informer.go) ---

func (s *KubernetesResourcerBase[T]) Watch(
    ctx context.Context,
    client *clients.ClientSet,
    meta resource.ResourceMeta,
    sink resource.WatchEventSink,
) error {
    // 1. Ensure the shared informer factory is started
    client.EnsureFactoryStarted(ctx)

    // 2. Get or create the informer for this GVR
    informer := client.DynamicInformerFactory.ForResource(s.resourceType).Informer()

    // 3. Register event handlers that forward to the SDK-provided sink
    registration, err := informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
        AddFunc: func(obj interface{}) {
            u := obj.(*unstructured.Unstructured)
            data, _ := u.MarshalJSON()
            sink.OnAdd(resource.WatchAddPayload{
                Resource: data,  // json.RawMessage (bytes-on-wire, doc 12)
            })
        },
        UpdateFunc: func(oldObj, newObj interface{}) {
            oldU := oldObj.(*unstructured.Unstructured)
            newU := newObj.(*unstructured.Unstructured)
            oldData, _ := oldU.MarshalJSON()
            newData, _ := newU.MarshalJSON()
            sink.OnUpdate(resource.WatchUpdatePayload{
                OldResource: oldData,
                NewResource: newData,
            })
        },
        DeleteFunc: func(obj interface{}) {
            u := obj.(*unstructured.Unstructured)
            data, _ := u.MarshalJSON()
            sink.OnDelete(resource.WatchDeletePayload{
                Resource: data,
            })
        },
    })
    if err != nil {
        return fmt.Errorf("failed to add event handler for %s: %w", s.resourceType.Resource, err)
    }

    // 4. Wait for initial sync (notify state via sink)
    sink.OnStateChange(resource.WatchStateEvent{State: resource.WatchStateSyncing})

    if !cache.WaitForCacheSync(ctx.Done(), informer.HasSynced) {
        sink.OnStateChange(resource.WatchStateEvent{
            State:   resource.WatchStateError,
            Message: "timed out waiting for cache sync",
        })
        return fmt.Errorf("cache sync timeout for %s", s.resourceType.Resource)
    }

    sink.OnStateChange(resource.WatchStateEvent{State: resource.WatchStateSynced})

    // 5. Block until context is cancelled (SDK manages lifecycle)
    <-ctx.Done()

    // 6. Cleanup: remove event handler
    if err := informer.RemoveEventHandler(registration); err != nil {
        s.log.Warnw("failed to remove event handler", "resource", s.resourceType.Resource, "error", err)
    }

    return ctx.Err()
}
```

### What This Replaces in informer.go

| informer.go Component | Where It Goes |
|---|---|
| `kubeInformerHandle` struct | **Deleted** — no central handle needed |
| `RegisterResource()` | Replaced by `Watch()` on each resourcer — SDK calls it per-resource |
| `Start()` | `EnsureFactoryStarted()` on `ClientSet` + per-resourcer `Watch()` |
| `StartResource()` | SDK calls `Watch()` directly when subscription starts |
| `resolveGVR()` | Moves to `gvr.go` (see below) |
| `Stop()` | `DestroyClient()` on `ConnectionProvider` |
| `ignoreResources` list | Stays — consulted by code generator to skip registering those resources |
| `nonK8sGroups` list | Stays — Helm resourcers don't implement `Watcher`, so no informer is created |
| Event handler registration | Inline in `Watch()` — `cache.ResourceEventHandlerFuncs` |
| `addChan`/`updateChan`/`deleteChan` | Replaced by `WatchEventSink` methods |
| `stateChan` | Replaced by `sink.OnStateChange()` |
| Per-resource sync policy tracking | `SyncPolicyDeclarer` interface on resourcer (optional) |
| 30-second sync timeout | `ctx` deadline (SDK configurable) |

### gvr.go — Extracted Utility

```go
// gvr.go — extracted from informer.go
package resource

// resolveGVR dynamically resolves a GVR for CRDs that aren't in the static resourceMap.
// Used by DiscoveryProvider and pattern resourcer.
func resolveGVR(
    discovery discovery.DiscoveryInterface,
    meta resource.ResourceMeta,
) (schema.GroupVersionResource, error) {
    // Same logic as current kubeInformerHandle.resolveGVR
    // Uses discovery.ServerResourcesForGroupVersion()
}
```

---

## 5. Pattern Resourcer

### Current

```go
type KubernetesPatternResourcer struct {
    sync.RWMutex
    log *zap.SugaredLogger
}

func (s *KubernetesPatternResourcer) Get(
    ctx *types.PluginContext,
    client *clients.ClientSet,
    meta pkgtypes.ResourceMeta,
    input pkgtypes.GetInput,
) (*pkgtypes.GetResult, error) {
    // Constructs REST path from meta, calls DynamicClient
}
```

### v1

```go
type KubernetesPatternResourcer struct {
    sync.RWMutex
    log *zap.SugaredLogger
}

// Compile-time check — Resourcer ONLY, no Watcher
var _ resource.Resourcer[clients.ClientSet] = (*KubernetesPatternResourcer)(nil)

func (s *KubernetesPatternResourcer) Get(
    ctx context.Context,              // ← context.Context
    client *clients.ClientSet,
    meta resource.ResourceMeta,       // ← v1 types
    input resource.GetInput,
) (*resource.GetResult, error) {
    // Same REST-path construction logic
}

// List, Find, Create, Update, Delete — same pattern
```

### Key Decision: No Watcher

The pattern resourcer handles arbitrary/unknown resource types (CRDs, future APIs). It uses raw REST
calls and does **not** implement `Watcher[ClientSet]`. This means:

- CRDs discovered at runtime are CRUD-only until a dedicated resourcer is registered
- The SDK detects absence of `Watcher` and skips watch lifecycle for these resource types
- This matches current behavior — CRDs only get informers if they're in the static `resourceMap`

---

## 6. Code Generator

The code generator (`generators/`) auto-generates resource registrations from the Kubernetes OpenAPI
spec. The generated output format changes.

### Current Output (register_gen.go)

```go
sdk.RegisterResourcePlugin(plugin, sdk.ResourcePluginOpts[clients.ClientSet]{
    // ... 12 function fields ...
    Resourcers: map[types.ResourceMeta]types.Resourcer[clients.ClientSet]{
        {Group: "apps", Version: "v1", Kind: "Deployment", Description: "..."}:
            resourcers.NewKubernetesResourcerBase[resourcers.MetaAccessor](logger, appsv1...),
        // ... 200+ entries ...
    },
})
```

### v1 Output (register_v1.go)

```go
func kubeResources(logger *zap.SugaredLogger) []sdk.ResourceRegistration[clients.ClientSet] {
    return []sdk.ResourceRegistration[clients.ClientSet]{
        {
            Meta: resource.ResourceMeta{
                Group:       "apps",
                Version:     "v1",
                Kind:        "Deployment",
                Description: "...",
            },
            Resourcer:  resourcers.NewDeploymentResourcer(logger),  // specialized
            Definition: &resourcers.ResourceDefs["apps::v1::Deployment"],
        },
        {
            Meta: resource.ResourceMeta{
                Group:       "core",
                Version:     "v1",
                Kind:        "ConfigMap",
                Description: "...",
            },
            Resourcer:  resourcers.NewKubernetesResourcerBase[resourcers.MetaAccessor](
                logger,
                corev1.SchemeGroupVersion.WithResource("configmaps"),
            ),
            // Definition: nil → uses DefaultDefinition from config
        },
        // ... 200+ entries ...
    }
}
```

### Generator Template Changes

| Current Template | v1 Template |
|---|---|
| `map[types.ResourceMeta]types.Resourcer[clients.ClientSet]{` | `[]sdk.ResourceRegistration[clients.ClientSet]{` |
| Map key: `{Group: ..., Kind: ...}` | Struct field: `Meta: resource.ResourceMeta{...}` |
| Map value: `NewKubernetesResourcerBase[...]` | Struct field: `Resourcer: NewKubernetesResourcerBase[...]` |
| No definition binding | Optional `Definition: &resourcers.ResourceDefs[key]` |

### Specialized Resourcer Routing

The generator must route certain resource types to their specialized resourcers:

```go
// generator.go — specializedResourcers map (hardcoded, not generated)
var specializedResourcers = map[string]string{
    "core::v1::Node":               "resourcers.NewNodeResourcer(logger)",
    "apps::v1::Deployment":         "resourcers.NewDeploymentResourcer(logger)",
    "apps::v1::DaemonSet":          "resourcers.NewDaemonSetResourcer(logger)",
    "apps::v1::StatefulSet":        "resourcers.NewStatefulSetResourcer(logger)",
}
```

### resourceMap and gvrMap

The `resourceMap` (resource key → GVR) and `gvrMap` (GVR → resource key) are **still generated**.
They are used by:
- `resolveGVR()` in `gvr.go` (static lookup before falling back to discovery)
- `DiscoveryProvider` for mapping discovered CRDs
- `Watch()` for looking up GVRs from `ResourceMeta`

The maps move from `register_gen.go` to a separate `resource_map_gen.go` file that both old and new
registration code can import.

---

## 7. Actions

### Current

```go
// node_resourcer.go
func (n *NodeResourcer) GetActions(
    _ *types.PluginContext,
    _ *clients.ClientSet,
    _ pkgtypes.ResourceMeta,
) ([]pkgtypes.ActionDescriptor, error) {
    return []pkgtypes.ActionDescriptor{
        {
            ID:          "cordon",
            Label:       "Cordon Node",
            Description: "Mark the node as unschedulable",
            Icon:        "LuShieldBan",
            Scope:       pkgtypes.ActionScopeInstance,
        },
        // ...
    }, nil
}

func (n *NodeResourcer) ExecuteAction(
    ctx *types.PluginContext,
    client *clients.ClientSet,
    meta pkgtypes.ResourceMeta,
    actionID string,
    input pkgtypes.ActionInput,
) (*pkgtypes.ActionResult, error) {
    switch actionID {
    case "cordon":
        return n.cordon(ctx, client, meta, input)
    // ...
    }
}
```

### v1

```go
// node_resourcer.go
var _ resource.ActionResourcer[clients.ClientSet] = (*NodeResourcer)(nil)

func (n *NodeResourcer) GetActions(
    ctx context.Context,                    // ← context.Context
    client *clients.ClientSet,
    meta resource.ResourceMeta,
) ([]resource.ActionDescriptor, error) {
    return []resource.ActionDescriptor{
        {
            ID:          "cordon",
            Label:       "Cordon Node",
            Description: "Mark the node as unschedulable",
            Icon:        "LuShieldBan",
            Scope:       resource.ActionScopeInstance,
            // NEW fields (doc 13, 21):
            ParamsSchema: nil,  // no params needed
            Dangerous:    false,
        },
        {
            ID:          "drain",
            Label:       "Drain Node",
            Description: "Safely evict all pods from the node",
            Icon:        "LuArrowDownToLine",
            Scope:       resource.ActionScopeInstance,
            Dangerous:   true,  // NEW — UI shows confirmation dialog
            ParamsSchema: json.RawMessage(`{
                "type": "object",
                "properties": {
                    "gracePeriodSeconds": {"type": "integer", "default": 30},
                    "ignoreDaemonSets":   {"type": "boolean", "default": true},
                    "deleteEmptyDirData": {"type": "boolean", "default": false},
                    "force":              {"type": "boolean", "default": false}
                }
            }`),
        },
        // ...
    }, nil
}

func (n *NodeResourcer) ExecuteAction(
    ctx context.Context,                     // ← context.Context
    client *clients.ClientSet,
    meta resource.ResourceMeta,
    actionID string,
    input resource.ActionInput,
) (*resource.ActionResult, error) {
    // Same switch/case dispatch, ctx replaces ctx.Context
}
```

### StreamAction

Streaming actions (deployment restart, daemonset restart) use `StreamAction` instead of
`ExecuteAction`:

```go
func (d *DeploymentResourcer) StreamAction(
    ctx context.Context,
    client *clients.ClientSet,
    meta resource.ResourceMeta,
    actionID string,
    input resource.ActionInput,
    stream chan<- resource.ActionEvent,      // NEW — replaces embedded channel logic
) error {
    switch actionID {
    case "restart":
        return d.restart(ctx, client, meta, input, stream)
    default:
        return fmt.Errorf("unknown streaming action: %s", actionID)
    }
}
```

### New ActionDescriptor Fields

| Field | Type | Purpose |
|---|---|---|
| `ParamsSchema` | `json.RawMessage` | JSON Schema for action parameters — enables auto-generated UI forms and MCP tool schemas (doc 13) |
| `OutputSchema` | `json.RawMessage` | JSON Schema for action result — enables structured AI responses |
| `Dangerous` | `bool` | If true, engine shows confirmation dialog before execution |

---

## 8. Non-Resource Capabilities

Per doc 20 §13.7, exec, logs, metric, and networker are **not redesigned** in v1. They receive
import path changes only.

### What Changes

| Capability | Current Import | v1 Import |
|---|---|---|
| exec | `github.com/omniviewdev/plugin-sdk/pkg/exec/types` | `github.com/omniviewdev/plugin-sdk/pkg/v1/exec/types` |
| logs | `github.com/omniviewdev/plugin-sdk/pkg/logs/types` | `github.com/omniviewdev/plugin-sdk/pkg/v1/logs/types` |
| metric | `github.com/omniviewdev/plugin-sdk/pkg/metric/types` | `github.com/omniviewdev/plugin-sdk/pkg/v1/metric/types` |
| networker | `github.com/omniviewdev/plugin-sdk/pkg/networker/types` | `github.com/omniviewdev/plugin-sdk/pkg/v1/networker/types` |

### What Does NOT Change

- Function signatures (`TTYHandler`, `LogHandlerFunc`, `QueryFunc`, `ResourcePortForwarder`)
- `*types.PluginContext` parameter (migrated in future sprint)
- Registration pattern (`exec.Register(plugin)`, `pluginlogs.Register(plugin)`, etc.)
- Internal logic (remotecommand, SPDY, Prometheus client, etc.)

### K8s Plugin Files Affected

```
pkg/plugin/exec/register.go       — import path update
pkg/plugin/exec/node_handler.go   — import path update
pkg/plugin/logs/register.go       — import path update
pkg/plugin/logs/handler.go        — import path update
pkg/plugin/logs/sources.go        — import path update
pkg/plugin/metric/register.go     — import path update
pkg/plugin/metric/handler.go      — import path update
pkg/plugin/metric/prometheus.go   — no SDK imports
pkg/plugin/metric/detection.go    — no SDK imports
pkg/plugin/metric/cache.go        — import path update
pkg/plugin/metric/portforward.go  — no SDK imports
pkg/plugin/networker/register.go  — import path update
```

---

## 9. ResourceLink → RelationshipProvider

This is an **additive** capability — the current K8s plugin has no relationship declarations.

### v1 Interface (doc 18)

```go
type RelationshipProvider interface {
    GetRelationships(ctx context.Context) ([]RelationshipDescriptor, error)
}
```

### K8s Implementation

The K8s plugin implements `RelationshipProvider` as a top-level capability on the plugin config, not
per-resourcer. It declares well-known Kubernetes relationships:

```go
type kubeRelationshipProvider struct{}

func (k *kubeRelationshipProvider) GetRelationships(
    ctx context.Context,
) ([]resource.RelationshipDescriptor, error) {
    return []resource.RelationshipDescriptor{
        // Pod → Node (scheduled on)
        {
            Type:       resource.RelationshipRunsOn,
            FromType:   resource.ResourceMeta{Group: "core", Version: "v1", Kind: "Pod"},
            ToType:     resource.ResourceMeta{Group: "core", Version: "v1", Kind: "Node"},
            Extractor:  resource.JSONPathExtractor{Path: "$.spec.nodeName"},
        },
        // Deployment → ReplicaSet (owns)
        {
            Type:       resource.RelationshipOwns,
            FromType:   resource.ResourceMeta{Group: "apps", Version: "v1", Kind: "Deployment"},
            ToType:     resource.ResourceMeta{Group: "apps", Version: "v1", Kind: "ReplicaSet"},
            Extractor:  resource.OwnerRefExtractor{},
        },
        // ReplicaSet → Pod (owns)
        {
            Type:       resource.RelationshipOwns,
            FromType:   resource.ResourceMeta{Group: "apps", Version: "v1", Kind: "ReplicaSet"},
            ToType:     resource.ResourceMeta{Group: "core", Version: "v1", Kind: "Pod"},
            Extractor:  resource.OwnerRefExtractor{},
        },
        // Service → Pod (selects)
        {
            Type:       resource.RelationshipSelects,
            FromType:   resource.ResourceMeta{Group: "core", Version: "v1", Kind: "Service"},
            ToType:     resource.ResourceMeta{Group: "core", Version: "v1", Kind: "Pod"},
            Extractor:  resource.LabelSelectorExtractor{SelectorPath: "$.spec.selector"},
        },
        // PVC → PV (binds to)
        {
            Type:       resource.RelationshipBindsTo,
            FromType:   resource.ResourceMeta{Group: "core", Version: "v1", Kind: "PersistentVolumeClaim"},
            ToType:     resource.ResourceMeta{Group: "core", Version: "v1", Kind: "PersistentVolume"},
            Extractor:  resource.JSONPathExtractor{Path: "$.spec.volumeName"},
        },
        // Pod → PVC (uses)
        {
            Type:       resource.RelationshipUses,
            FromType:   resource.ResourceMeta{Group: "core", Version: "v1", Kind: "Pod"},
            ToType:     resource.ResourceMeta{Group: "core", Version: "v1", Kind: "PersistentVolumeClaim"},
            Extractor:  resource.JSONPathExtractor{Path: "$.spec.volumes[*].persistentVolumeClaim.claimName"},
        },
        // Pod → ConfigMap (uses)
        {
            Type:       resource.RelationshipUses,
            FromType:   resource.ResourceMeta{Group: "core", Version: "v1", Kind: "Pod"},
            ToType:     resource.ResourceMeta{Group: "core", Version: "v1", Kind: "ConfigMap"},
            Extractor:  resource.CompositeExtractor{Extractors: []resource.RelationshipExtractor{
                resource.JSONPathExtractor{Path: "$.spec.volumes[*].configMap.name"},
                resource.JSONPathExtractor{Path: "$.spec.containers[*].envFrom[*].configMapRef.name"},
            }},
        },
        // Pod → Secret (uses)
        {
            Type:       resource.RelationshipUses,
            FromType:   resource.ResourceMeta{Group: "core", Version: "v1", Kind: "Pod"},
            ToType:     resource.ResourceMeta{Group: "core", Version: "v1", Kind: "Secret"},
            Extractor:  resource.CompositeExtractor{Extractors: []resource.RelationshipExtractor{
                resource.JSONPathExtractor{Path: "$.spec.volumes[*].secret.secretName"},
                resource.JSONPathExtractor{Path: "$.spec.containers[*].envFrom[*].secretRef.name"},
            }},
        },
        // Pod → ServiceAccount (uses)
        {
            Type:       resource.RelationshipUses,
            FromType:   resource.ResourceMeta{Group: "core", Version: "v1", Kind: "Pod"},
            ToType:     resource.ResourceMeta{Group: "core", Version: "v1", Kind: "ServiceAccount"},
            Extractor:  resource.JSONPathExtractor{Path: "$.spec.serviceAccountName"},
        },
        // Ingress → Service (routes to)
        {
            Type:       resource.RelationshipRoutesTo,
            FromType:   resource.ResourceMeta{Group: "networking", Version: "v1", Kind: "Ingress"},
            ToType:     resource.ResourceMeta{Group: "core", Version: "v1", Kind: "Service"},
            Extractor:  resource.JSONPathExtractor{Path: "$.spec.rules[*].http.paths[*].backend.service.name"},
        },
        // DaemonSet → Pod (owns)
        {
            Type:       resource.RelationshipOwns,
            FromType:   resource.ResourceMeta{Group: "apps", Version: "v1", Kind: "DaemonSet"},
            ToType:     resource.ResourceMeta{Group: "core", Version: "v1", Kind: "Pod"},
            Extractor:  resource.OwnerRefExtractor{},
        },
        // StatefulSet → Pod (owns)
        {
            Type:       resource.RelationshipOwns,
            FromType:   resource.ResourceMeta{Group: "apps", Version: "v1", Kind: "StatefulSet"},
            ToType:     resource.ResourceMeta{Group: "core", Version: "v1", Kind: "Pod"},
            Extractor:  resource.OwnerRefExtractor{},
        },
        // Job → Pod (owns)
        {
            Type:       resource.RelationshipOwns,
            FromType:   resource.ResourceMeta{Group: "batch", Version: "v1", Kind: "Job"},
            ToType:     resource.ResourceMeta{Group: "core", Version: "v1", Kind: "Pod"},
            Extractor:  resource.OwnerRefExtractor{},
        },
        // CronJob → Job (owns)
        {
            Type:       resource.RelationshipOwns,
            FromType:   resource.ResourceMeta{Group: "batch", Version: "v1", Kind: "CronJob"},
            ToType:     resource.ResourceMeta{Group: "batch", Version: "v1", Kind: "Job"},
            Extractor:  resource.OwnerRefExtractor{},
        },
    }, nil
}
```

### Extractor Types

The SDK provides built-in extractors that cover most K8s relationship patterns:

| Extractor | Purpose | K8s Use Case |
|---|---|---|
| `OwnerRefExtractor` | Walks `metadata.ownerReferences` | Deployment→RS, RS→Pod, Job→Pod |
| `LabelSelectorExtractor` | Matches `.spec.selector` against target labels | Service→Pod |
| `JSONPathExtractor` | Extracts a reference by JSON path | Pod→Node (`.spec.nodeName`), PVC→PV (`.spec.volumeName`) |
| `CompositeExtractor` | Combines multiple extractors | Pod→ConfigMap (volumes + envFrom) |

---

## 10. HealthProvider

This is an **additive** capability — the current K8s plugin has no health normalization.

### v1 Interface (doc 19)

```go
type HealthProvider interface {
    GetHealth(ctx context.Context, client *ClientT, meta ResourceMeta, resource json.RawMessage) (*ResourceHealth, error)
}
```

### K8s Implementation

Health normalization is implemented **per specialized resourcer** via optional interface assertion.
Not all resourcers implement it — only those with meaningful health semantics.

```go
// Pod health — derives from pod phase + conditions
type PodHealthProvider struct{}

func (p *PodHealthProvider) GetHealth(
    ctx context.Context,
    client *clients.ClientSet,
    meta resource.ResourceMeta,
    data json.RawMessage,
) (*resource.ResourceHealth, error) {
    var pod corev1.Pod
    if err := json.Unmarshal(data, &pod); err != nil {
        return nil, err
    }

    health := &resource.ResourceHealth{
        Status: resource.HealthStatusUnknown,
    }

    switch pod.Status.Phase {
    case corev1.PodRunning:
        health.Status = resource.HealthStatusHealthy
        // Check container restarts for degraded
        for _, cs := range pod.Status.ContainerStatuses {
            if cs.RestartCount > 5 {
                health.Status = resource.HealthStatusDegraded
                health.Message = fmt.Sprintf("container %s has %d restarts", cs.Name, cs.RestartCount)
            }
            if cs.State.Waiting != nil && cs.State.Waiting.Reason == "CrashLoopBackOff" {
                health.Status = resource.HealthStatusUnhealthy
                health.Message = fmt.Sprintf("container %s in CrashLoopBackOff", cs.Name)
            }
        }
    case corev1.PodSucceeded:
        health.Status = resource.HealthStatusHealthy
    case corev1.PodFailed:
        health.Status = resource.HealthStatusUnhealthy
        health.Message = pod.Status.Message
    case corev1.PodPending:
        health.Status = resource.HealthStatusProgressing
    }

    // Conditions as HealthConditions
    for _, c := range pod.Status.Conditions {
        health.Conditions = append(health.Conditions, resource.HealthCondition{
            Type:    string(c.Type),
            Status:  string(c.Status),
            Message: c.Message,
            Since:   c.LastTransitionTime.Time,
        })
    }

    return health, nil
}
```

### Resourcers That Implement HealthProvider

| Resource Type | Health Logic |
|---|---|
| **Pod** | Phase → status mapping, container restart counts, CrashLoopBackOff detection |
| **Node** | `Ready` condition → Healthy/Unhealthy, `MemoryPressure`/`DiskPressure` → Degraded |
| **Deployment** | `Available` condition, `spec.replicas` vs `status.availableReplicas` |
| **StatefulSet** | `status.readyReplicas` vs `spec.replicas` |
| **DaemonSet** | `status.numberReady` vs `status.desiredNumberScheduled` |
| **PVC** | `status.phase` (Bound → Healthy, Pending → Progressing, Lost → Unhealthy) |
| **Service** | Always Healthy for ClusterIP; LoadBalancer checks `status.loadBalancer.ingress` |

### Integration

Health providers are registered via interface assertion on the specialized resourcer:

```go
// The NodeResourcer already exists — just add the HealthProvider method
type NodeResourcer struct {
    *KubernetesResourcerBase[MetaAccessor]
    log *zap.SugaredLogger
}

var _ resource.HealthProvider[clients.ClientSet] = (*NodeResourcer)(nil)

func (n *NodeResourcer) GetHealth(
    ctx context.Context,
    client *clients.ClientSet,
    meta resource.ResourceMeta,
    data json.RawMessage,
) (*resource.ResourceHealth, error) {
    // Node-specific health normalization
}
```

Base resourcers (`KubernetesResourcerBase`) do **not** implement `HealthProvider` — health is only
available for resource types with specialized resourcers.

---

## 11. Registration & main.go

### Current main.go

```go
func main() {
    plugin := sdk.NewPlugin(sdk.PluginOpts{
        ID:       "kubernetes",
        Settings: []settings.Setting{...},
    })

    resource.Register(plugin)     // registers resource capability via ResourcePluginOpts
    exec.Register(plugin)
    networker.Register(plugin)
    pluginlogs.Register(plugin)
    pluginmetric.Register(plugin)

    plugin.Serve()
}
```

### Current Register() (register_gen.go)

```go
func Register(plugin *sdk.Plugin) {
    sdk.RegisterResourcePlugin(plugin, sdk.ResourcePluginOpts[clients.ClientSet]{
        CreateClient:                 clients.CreateClient,
        RefreshClient:                clients.RefreshClient,
        ErrorClassifier:              classifyResourceError,
        DiscoveryProvider:            sdk.NewClientDiscoveryProvider(...),
        LoadConnectionFunc:           LoadConnectionsFunc,
        WatchConnectionsFunc:         WatchConnectionsFunc,
        LoadConnectionNamespacesFunc: LoadConnectionNamespacesFunc,
        CheckConnectionFunc:          CheckConnectionFunc,
        CreateInformerFunc:           NewKubeInformerHandle,
        ResourceGroups:               ResourceGroups,
        ResourceDefinitions:          resourceDefs,
        DefaultResourceDefinition:    resourcers.DefaultResourceDef,
        SchemaFunc:                   func(...) { ... },
        PatternResourcers:            map[string]Resourcer[ClientSet]{"*": ...},
        Resourcers:                   map[ResourceMeta]Resourcer[ClientSet]{...200+ entries...},
    })
}
```

### v1 main.go

```go
func main() {
    plugin := sdk.NewPlugin(sdk.PluginOpts{
        ID:       "kubernetes",
        Settings: []settings.Setting{...},  // unchanged
    })

    resource.Register(plugin)        // NEW registration using ResourcePluginConfig
    exec.Register(plugin)            // import path change only
    networker.Register(plugin)       // import path change only
    pluginlogs.Register(plugin)      // import path change only
    pluginmetric.Register(plugin)    // import path change only

    plugin.Serve()
}
```

### v1 Register() (register_v1.go)

```go
func Register(plugin *sdk.Plugin) {
    logger := zap.S()
    connProvider := &kubeConnectionProvider{logger: logger}

    sdk.RegisterResourcePlugin(plugin, sdk.ResourcePluginConfig[clients.ClientSet]{
        // Required
        Connections: connProvider,

        // Resource registrations (generated)
        Resources: kubeResources(logger),
        Patterns: map[string]resource.Resourcer[clients.ClientSet]{
            "*": resourcers.NewKubernetesPatternResourcer(logger),
        },

        // Resource metadata
        Groups:            ResourceGroups,
        DefaultDefinition: resourcers.DefaultResourceDef,

        // Optional capabilities (auto-detected via interface assertion)
        Discovery:       &kubeDiscoveryProvider{logger: logger},
        ErrorClassifier: &kubeErrorClassifier{},

        // Relationships (doc 18) — additive
        Relationships: &kubeRelationshipProvider{},
    })
}
```

### What Disappeared

| ResourcePluginOpts Field | Where It Went |
|---|---|
| `CreateClient` | `ConnectionProvider.CreateClient()` |
| `RefreshClient` | `ClientRefresher.RefreshClient()` (auto-detected on `ConnectionProvider`) |
| `LoadConnectionFunc` | `ConnectionProvider.LoadConnections()` |
| `WatchConnectionsFunc` | `ConnectionWatcher.WatchConnections()` (auto-detected on `ConnectionProvider`) |
| `LoadConnectionNamespacesFunc` | `ConnectionProvider.GetNamespaces()` |
| `CheckConnectionFunc` | `ConnectionProvider.CheckConnection()` |
| `CreateInformerFunc` | **Gone** — replaced by `Watcher.Watch()` on each resourcer |
| `ResourceDefinitions` | `ResourceRegistration.Definition` (per-resource) |
| `SchemaFunc` | `SchemaProvider.GetEditorSchemas()` (auto-detected on `ConnectionProvider`) |
| `ErrorClassifier` (function) | `ErrorClassifier` (interface) on config |
| `DiscoveryProvider` (SDK helper) | `DiscoveryProvider` (interface) on config |

---

## 12. Verification Checklist

### Compile-Time Checks

```go
// connection_provider.go
var _ resource.ConnectionProvider[clients.ClientSet]    = (*kubeConnectionProvider)(nil)
var _ resource.ConnectionWatcher                        = (*kubeConnectionProvider)(nil)
var _ resource.ClientRefresher[clients.ClientSet]       = (*kubeConnectionProvider)(nil)
var _ resource.SchemaProvider[clients.ClientSet]         = (*kubeConnectionProvider)(nil)

// resourcers/base.go
var _ resource.Resourcer[clients.ClientSet]  = (*KubernetesResourcerBase[MetaAccessor])(nil)
var _ resource.Watcher[clients.ClientSet]    = (*KubernetesResourcerBase[MetaAccessor])(nil)

// resourcers/pattern_resourcer.go
var _ resource.Resourcer[clients.ClientSet]  = (*KubernetesPatternResourcer)(nil)

// resourcers/node_resourcer.go
var _ resource.Resourcer[clients.ClientSet]       = (*NodeResourcer)(nil)
var _ resource.ActionResourcer[clients.ClientSet]  = (*NodeResourcer)(nil)
var _ resource.HealthProvider[clients.ClientSet]    = (*NodeResourcer)(nil)

// resourcers/deployment_resourcer.go
var _ resource.Resourcer[clients.ClientSet]       = (*DeploymentResourcer)(nil)
var _ resource.ActionResourcer[clients.ClientSet]  = (*DeploymentResourcer)(nil)
var _ resource.HealthProvider[clients.ClientSet]    = (*DeploymentResourcer)(nil)

// helm/resourcer.go — CRUD-only, no Watcher
var _ resource.Resourcer[clients.ClientSet]  = (*HelmReleaseResourcer)(nil)
```

### Integration Test Cases

| # | Test | Expected |
|---|---|---|
| 1 | `RegisterResourcePlugin` compiles with `ResourcePluginConfig[ClientSet]` | Compiles |
| 2 | Plugin starts, go-plugin negotiates v1 | `GetInfo` returns `sdk_version: 1` |
| 3 | `LoadConnections` returns kubeconfig contexts | ≥1 connection |
| 4 | `StartConnection` creates `ClientSet`, informer factory NOT started | Factory `Start()` not called |
| 5 | `EnsureResourceWatch("core::v1::Pod")` triggers `Watch()` on PodResourcer | `sink.OnStateChange(Syncing)` then `sink.OnStateChange(Synced)` |
| 6 | `EnsureFactoryStarted` called exactly once across multiple `Watch()` calls | `sync.Once` guarantees |
| 7 | `Get("core::v1::Pod")` returns pod data as `json.RawMessage` | Valid JSON, no intermediate `map[string]interface{}` |
| 8 | `List("apps::v1::Deployment")` returns all deployments | Success |
| 9 | `GetActions("core::v1::Node")` returns 6 actions with `ParamsSchema` | drain has JSON Schema |
| 10 | `ExecuteAction("core::v1::Node", "cordon")` marks node unschedulable | Node `.spec.unschedulable == true` |
| 11 | Pattern resourcer handles unknown CRD via REST | CRUD succeeds, no `Watcher` → no watch |
| 12 | Helm release `List` works (CRUD-only) | Returns releases, no informer created |
| 13 | `GetRelationships` returns ≥13 relationship descriptors | Deployment→RS, RS→Pod, Pod→Node, etc. |
| 14 | `GetHealth("core::v1::Pod")` returns health for running pod | `HealthStatusHealthy` |
| 15 | `GetHealth("core::v1::Pod")` detects CrashLoopBackOff | `HealthStatusUnhealthy` |
| 16 | `GetEditorSchemas` returns OpenAPI schemas | ≥1 schema |
| 17 | `StopConnection` calls `DestroyClient`, factory shuts down | No goroutine leak |
| 18 | Exec capability still works (import path only) | Pod exec session opens |
| 19 | Logs capability still works (import path only) | Pod log stream flows |
| 20 | Metric capability still works (import path only) | Pod metrics returned |

### Migration Completion Gate

Before switching `loader.go` to use v1 (doc 20 §14 Phase 3):

- [ ] All compile-time checks pass (`go build ./plugins/kubernetes/...`)
- [ ] All 20 integration test cases pass
- [ ] No references to `pkg/types.PluginContext` in resource capability code
- [ ] No references to old `pkg/resource/types` (only `pkg/v1/resource`)
- [ ] `informer.go` deleted, `gvr.go` created
- [ ] `register_gen.go` deleted, `register_v1.go` + `resource_map_gen.go` created
- [ ] Non-resource capabilities compile with `pkg/v1/{exec,logs,metric,networker}` imports
- [ ] Full E2E test suite passes (connect to real cluster, CRUD, watch, actions)

---

## Appendix A: Discovery Provider

### Current

The current `DiscoveryProvider` uses an SDK helper that wraps a function:

```go
sdk.NewClientDiscoveryProvider(clients.CreateDiscoveryClient, nil, DiscoveryFunc)
```

### v1

```go
type kubeDiscoveryProvider struct {
    logger *zap.SugaredLogger
}

var _ resource.DiscoveryProvider = (*kubeDiscoveryProvider)(nil)

func (k *kubeDiscoveryProvider) Discover(
    ctx context.Context,
    conn *types.Connection,
) ([]resource.ResourceMeta, error) {
    // Create a discovery client from connection data
    // (needs clientFactory — inject via constructor or derive from Session)
    session := resource.SessionFromContext(ctx)

    // Build rest.Config from session.Connection
    restConfig, err := kubeauth.BuildRESTConfig(session.Connection)
    if err != nil {
        return nil, err
    }

    discoveryClient, err := discovery.NewDiscoveryClientForConfig(restConfig)
    if err != nil {
        return nil, err
    }

    // Same discovery logic as current DiscoveryFunc
    // Enumerate API groups → resources → return []ResourceMeta
}

func (k *kubeDiscoveryProvider) OnConnectionRemoved(
    ctx context.Context,
    conn *types.Connection,
) error {
    // Cleanup cached discovery state for this connection
    return nil
}
```

### Client Acquisition Decision

The discovery provider needs a Kubernetes client to query the API server, but it runs **outside**
the normal CRUD flow (before `CreateClient` may have been called). Options considered:

1. ~~Inject `ConnectionProvider` directly~~ — creates circular dependency
2. ~~Call `CreateClient` internally~~ — expensive, creates second client
3. **Build lightweight discovery client from connection data** ← chosen

The `DiscoveryProvider` builds a minimal `rest.Config` from `Session.Connection.Data` (which
contains kubeconfig path and context name) and creates only a `DiscoveryClient`. This is cheap
and doesn't duplicate the full `ClientSet`.

---

## Appendix B: Helm Resourcers

Helm resourcers are a special case: they access a cluster's Helm releases, charts, and repos
but are **not backed by the Kubernetes API**. They cannot use `DynamicSharedInformerFactory`.

### Current

Helm resourcers implement `Resourcer[ClientSet]` and use the K8s client to query Helm state
(release secrets, configmaps). They are registered in `register_gen.go` alongside K8s resources.

### v1

```go
// Helm resourcers implement Resourcer[ClientSet] but NOT Watcher[ClientSet]
var _ resource.Resourcer[clients.ClientSet] = (*HelmReleaseResourcer)(nil)
// No Watcher — CRUD-only. The SDK detects this and skips watch lifecycle.

// Registered with group "helm" — nonK8sGroups list prevents any watch attempt
```

### Key Decision: No Watcher for Helm

Helm releases change infrequently and have no native watch mechanism. Making them CRUD-only is
the correct design — users refresh manually or the SDK polls if a `SyncPolicy` with periodic
refresh is declared (future).

---

## Appendix C: Migration Sequence

This appendix maps to doc 20 §14 phases with K8s-specific detail.

### Phase 1 (SDK v1 packages — no K8s changes)

SDK team builds:
- `plugin-sdk/pkg/v1/resource/` — all interfaces
- `plugin-sdk/proto/v1/` — all proto definitions (doc 21)
- Engine `adapter_v1.go` — translates proto ↔ canonical types
- Engine `controller_v1.go` — new controller using canonical `ResourceProvider`

K8s plugin: **no changes yet**.

### Phase 2 (K8s plugin implements v1)

1. Create `connection_provider.go` (§3)
2. Modify `clients/clients.go` — add `EnsureFactoryStarted()` (§2)
3. Modify `resourcers/base.go` — `context.Context` + `Watch()` (§4)
4. Modify `resourcers/pattern_resourcer.go` — `context.Context` (§5)
5. Modify specialized resourcers — `context.Context` + new `ActionDescriptor` fields (§7)
6. Create `gvr.go` — extract `resolveGVR()` (§4)
7. Update code generator — new template (§6)
8. Re-run code generator → `register_v1.go` + `resource_map_gen.go`
9. Create `kubeDiscoveryProvider` (Appendix A)
10. Create `kubeRelationshipProvider` (§9)
11. Create health providers on specialized resourcers (§10)
12. Create `kubeErrorClassifier` (§3 migration notes)
13. Modify helm resourcers — `context.Context` (Appendix B)
14. Update non-resource capability imports (§8)
15. Delete `informer.go`
16. Delete `register_gen.go`
17. Run all compile-time checks (§12)

### Phase 3 (Switch over)

- Update `loader.go` to use `VersionedPlugins{1: v1PluginSet}`
- Update K8s `main.go` to register with v1 SDK
- Run full integration + E2E test suite

### Phase 4 (Cleanup)

- Delete old `plugin-sdk/pkg/resource/` (unversioned)
- Delete old `plugin-sdk/proto/*.proto` (unversioned)
- Delete old engine controllers
